K3 的那些事儿
===

## Telnet TTL 强开

反编译 telnetd_startup 从 “telnetd default” 一路查找调用点即可看到有读取 `/dev/mtd4` （pro_info）的第 7、8 字节的操作。如果分别是 0x10、0x70 则自动启动 utelnetd. 于是连 TTL `cat` 出来，手改，`cat` 回去即可（坑爹固件没有 `dd`）。

## Telnet 免拆开启 & 启用 debug flag

完整反编译 telnetd_startup，会发现它有 UDP 监听端口（从 `socket` 和 `bind` 的调用入手）。跟着到 `recv` 的循环里，可以发现有两条路径，一条是直接进行某种检查后设置一个变量，另一条是检查这个变量后再进行另外的检查。后一条路径上能直接看到写 pro_info 和开 utelnetd 的流程（中间有些繁杂的代码省略了）。那么看起来就是个敲门的过程了：先发个包走前一流程，再发包就会进入后一流程，后发的这个包可以用于开启 telnet. 虽然很猥琐，不过确实很安全呢~ 再加上是 UDP，不保证有回应（Port unreachable 算么）所以能避开端口扫描，贼溜。

具体来说，前一个包发送一个随机字符串加密后的结果，telnetd_startup 会解密，得出原始字符串，存进缓冲。后一个包发送这个字符串与另一个写死的特定串（这个串有两种选择，一种用来临时开 telnet，另一种用来写 0x10 0x70 但不启动 utelnetd）的拼接结果 hash 出来的结果，telnetd_startup 会把上一步解密出的字符串分别拼接这两种特定串，自己分别算出两个 hash，然后与发来的包比较。如果有一致的，那就视匹配情况开启 telnet 或者写入 0x10 0x70.

看到这两个检查的函数后要构造合适的数据包就很简单了。要注意的是，前一检查会把它的解密结果存下来供后一流程用（也就是说除了那个敲过门的 flag 以外还有其他结果也传下来了），所以构造前一个数据包的时候原始数据要方便为自己所用，否则第二个数据包不好构造了。

## TRX 固件转官方 web 可刷格式

反编译 httpd，可以看到调用了 `upgrade_{check|write}` 这几个函数。它们实现在 `libupgrade.so` 里面，反编译它可以看到一些格式说明。`upgrade_check` 会一次读取文件中的前 0x80400 字节。0 ~ 0x80000 没指定是干嘛的，但 0x80000 处有特定 magic 匹配，几字节以后有三个 int（用到了 `ntohl`，说明文件里是大端的），通过后续的有效性检查提示文字可以判断这几个参数的意义——分别是文件总大小、固件信息区块的大小以及一个不知道是干嘛的区块大小。最后一个大小可以为 0. 在这三个 int 以后还有一段 16 字节的东西。

拿出官方给的 web 刷机固件对比，可以发现 0 ~ 0x80000 是 CFE 分区，固件 TRX 从 0x80400 字节起存放，且前面所说的文件总大小只是到 TRX 结束为止，不包括后两个区块的大小。固件信息区块是指跟在 TRX 后面的一个 JSON（加密的），其中包含本固件版本、适用硬件型号、刷写所需最低版本等信息。固件信息区块占用 0x20000 字节，但有效信息的长度在前面 0x80000 附近给出。如果最后一个不知道干嘛的区块还存在的话（前面指定的长度不为 0），它也会占用 0x20000 字节，有效信息长度同上。那 16 字节暂且不知道是干嘛的。

继续分析 `upgrade_check`. magic 匹配、大小检测也过了以后，就会按文件总大小（不带后两个区块）把剩余部分（也就是 TRX）读进来填充到最初的 0x80400 字节后面。然后拿文件总大小做些运算，得到四个 int，替换掉读取缓冲区里那 16 字节的东西。然后对目前的读取缓冲区做 hash，拿去与原文件里的 16 字节比较，如果相同的话就证明固件文件有效，继续下一步。这个方法可厉害了，hash 存到文件正中间，然后计算时替换成已知量再 hash。虽然是常见的方法，但是在路由器上用是不是有点小题大做了…… 要真是想保护文件完整性，直接 hash 后面的 TRX 不就好了？前面 0x80000 字节的 CFE 也可以有自己的 hash 存在这里啊，反正中间这个 0x80000 ~ 0x80400 的校验块那么大，把文件里的每个块都 hash 了都够用。

固件有效性校验过了以后，就会把固件信息区块的加密 JSON 读出来，解密之，得到固件版本要求、硬件型号要求啥的，比较一下，符合了就开刷。这里就没啥好说的了。

分析到这里，就已经能够做出能通过校验的固件了。前面 CFE 那部分直接拿原厂备份拼接上去就好了，不需要操心。但是有个问题， `upgrade_write` 会直接调用 `system("write $path linux")` 来写固件，而刚才的固件又是 CFE 又是校验块又是固件信息块的，肯定不能原样刷进 Flash 的。那么是哪里把固件 TRX 和 CFE 分离出来单独刷的呢？找遍了 httpd 和 libupgrade.so 都没找到，最后发现是 rc 里的 `write` 这个指令会按上述流程再次校验固件，如果通过，就把 TRX 那部分提出来写到命令行上指定的地方。而如果最后一个信息区块存在的话，就会把前面的 CFE 也提出来写到对应位置。这个工作放在 `write` 这个指令来做，真的不是僭越了吗……